---
layout: post
title: Linux Kernel-From User Space To Kernel Space(WIP)
subtitle: picture from https://www.pexels.com/search/wild%20animals/
author: maxshuang
categories: Linux-Kernel
banner:
    image: /assets/images/post/linux-kernel-user-kernel-space/pexels-lucas-pezeta.jpg
    opacity: 0.618
    background: "#000"
    height: "70vh"
    min_height: "38vh"
    heading_style: "font-size: 3.00em; font-weight: bold; text-decoration: underline"
    subheading_style: "color: gold"
tags: Linux-Kernel CPU
---

# 用户态和内核态切换
在之前的博客中，我们一直在介绍内存相关的话题，因为我觉得内存在一切逻辑和数据的载体，<font size=4>需要先搞清楚事物的存在形式，再讨论事物的组织形式和运作形式</font>。
所以我们从最核心的内核加载出发，介绍到物理内存页的管理和小内存分配，再到最后的内核给业务实体提供的抽象概念：进程线性地址空间。关于内存的一些核心概念我觉得大致上介绍完了，
注意实际实现还是很复杂的，需要考虑效率上的诸多细节。

这篇开始我们专注于 CPU 相关的概念，也就是事物是如何运行的。

## 用户态和内核态
这两个概念对于做后台开发的同学而言很熟悉，最常听见的说法是：要减少用户态到内核态的切换，避免不必要的开销。要说清楚这两个概念，我们也从几个问题开始：
1. 用户态和内核态是什么？
2. 用户态和内核态的存在形式是什么？
3. 用户态、内核态和内核的关系是什么？
4. 用户态切换内核态，内核态切换用户态都有哪些时机？

对于这几个问题，一个简单的回答是这样的：
1. 用户态是 CPU 在执行用户编写的逻辑和数据时的状态；内核态是 CPU 在执行内核代码和访问内核数据时的状态。
内核态可以访问一些硬件相关的操作，权限更高。
2. 用户态的存在形式是用户编写的逻辑和关联的数据；内核态的存在形式是内核代码和内核关联数据。
3. 用户态和内核关系不大，内核态时执行的是内核的代码和关联数据。
4. 用户在访问硬件资源时，比如读写文件，获取网络数据包等，依赖内核提供的系统调用完成从用户态到内核态的切换。中断也会导致用户态到内核态的切换。当内核态执行完成之后，返回用户态。

这个回答完全符合对于用户态和内核态的定义。但是我们需要知道为什么要这些概念，如何实现这些概念，以及用户态和内核态这两个概念的关系和交互。

我们把视角再往回拨一下。在内存篇中，我们知道了进程的分页机制，本质上除了为用户隔离物理内存的相关概念之外，还可以提高物理内存利用率，因为我不需要提前将具体某块大小的物理内存区间
提前分配给进程 A。每个进程都是以一样的进程页表机制获取物理内存，只有在访问线性地址页时发现没有分配物理内存页的情况下才能分配物理内存。
这里的关键问题是，查找页表和分配物理内存这个行为本身是高危的，要防止贪婪和恶意的用户编写代码操作这个行为，这样会和内核产生冲突，同时会影响其他进程实体的数据安全。相同的原理可以对应
到操作文件和网络设备，网络数据包是按时间顺序到达的，没有内核合理的分发，其他进程就可能获取到本进程的数据包，导致本进程数据包不完整。

所以这里就出现了需求，对于高危操作，所有进程都要委托给内核操作，并且内核代码和关联数据都要设置高权限，即使用户用汇编自己构造合法的线性地址，也没法访问对应的内核代码和操作内核数据。
这就是用户态和内核态概念出现的原因。Linux 内核是为多进程多用户服务了，内核除了要维护分时复用和进程线性空间这些抽象概念之外，还要考虑到独立实体之间的数据和自身核心操作的安全问题。
（这类有个表述上关联的小细节问题，就是在整个进程线性地址中，既有用户自己的代码区/数据区/堆区/栈区等等，还有内核映射的每个进程高线性地址区间[3G, 4)，所以用户是可以用汇编语言自己构造
访问位于内核所在的高线性区间的。虽然 CPU 此时权限不足无法访问内核线性区间，但是这样理解可以加深我们对于用户态和内核态在权限管理上的区别）。

除了给不同的线性区赋予权限之外，为了实现内核态，我们还需要知道一个问题：
* 怎么防止用户构造指令切换到高权限，从而访问高权限的数据？在一切都是机器码的前提下，既然系统调用可以切换到内核，为什么用户就不可以？

## 硬件相关的执行权限控制
这里设计到硬件相关的权限设置，在内存分段的时候我们提及过段寄存器的概念，其中的 cs 代码段寄存器的段选择符就承载了 CPU 当前执行特权级。具体的，cs 段寄存器的 CPL 2bit 就是 CPU 的特权级，
0 为内核态，3 为用户态。

假设用户想要自己提高 CPU 权限，直接用汇编 asm("move $Kernel_Code %cs"), 这样 CPU 执行到这句时会给进程产生一个 General Protection Fault 的异常，因为 CPU 发现此时的用户态权限
无法操作控制寄存器。

这样除非是通过中断，异常或者内核提供的系统调用的方式，用户是没法通过自己构造线性地址或者操作一些控制寄存器的方式访问内核的代码和数据。除非内核有 bug 导致执行了某些内核逻辑之后一些控制寄存器
没有正确设置就切换回用户态，导致用户有机会能获取到权限。

这里简单提及下中断中，硬件是如何参与到用户态和内核态切换的。当 CPU 在执行完一条指令后，CPU 会检查在指令执行期间是不是有中断或者异常发生。如果发现有对应的电信号，CPU 中的一些硬件电路会自动
保存 cs 和 eip 等的值到内核栈(暂时不解释这个概念)中，然后再找到内核中中断处理程序，设置 cs 和 eip 等将执行流切换过去。注意，这里的从检测到中断信号，一直跳转中断处理程序都是硬件做的。但是后面
cs 寄存器的切换导致的 CPU 权限切换是内核的逻辑。

## 用户态切换内核态时机
在三种场景下，用导致用户态切换内核态：
* 中断
* 异常
* 系统调用

中断是 Intel 定义的随机产生的硬件电信号导致的一类异步事件，比如敲击键盘，网络数据包到达和时钟中断等。相对于执行流，一般情况下这些硬件电信号稀疏的，但是对实时性要求会比一般程序要高，内核需要尽快处理这些中断电信号。
异常是 Intel 定义的同步中断，也会打断当前 CPU 的执行流。但是在产生时机上它是指令执行过程中的异常导致的，比如执行指令遇到了"除 0"，"溢出" 和上面说的由于权限不足导致的 "General Protection Fault"。
系统调用是内核提供给用户访问硬件资源的唯一方式。通过内核预定义的各种文件/网络系统调用，用户程序完成用户态到内核态的切换，并向内核申报了需要对硬件操作的信息，同时也允许内核在资源未准备好时做些其他事情，比如切换到其他进程执行，
等硬件资源准备好之后再切换回用户态，继续执行。

### 中断
1. 中断触发和区分
中断是硬件电信号触发的异步事件，在硬件上依赖 IRQ 线和 8259A 中断控制器，电信专业的同学在上微电子课的时候会接触到这些硬件单元。每个能够发出中断请求的硬件会通过 IRQ 线连接到中断控制器中，每次触发电信号时中断控制器就把引脚
序号转换成中断向量，通过不同的中断向量区分不同的中断类型，比如是键盘触发还是网卡触发。

2. 中断处理程序
有对应的硬件机制区分不同的中断类型之后，自然需要不同的中断处理程序，这些中断处理程序是内核中的一段逻辑，注意不是进程或者线程。对于操作系统抽象了解不深的同学会难以想象用户进程和内核逻辑、中断处理程序之间的关系，没法在脑海中当发生中断
或者异常或者系统调用时，执行流到底是怎么切换的。  
一种比较好的方式是，想象只有一个 CPU，那么在一个事件点就只能做一件事情。然后不管是内核，还是进程，还是中断处理程序都是一段要顺序执行的代码逻辑。然后 CPU 上有个电信号能够打断 CPU 当前的执行流，保存在特定的地方等待恢复，不管怎么打断
又选择其中的哪个执行，最终也就是在内核逻辑，进程逻辑或者中断处理逻辑中跳来跳去而已。核心还是能够随时打断并恢复执行流的能力，而不管内核或者用户逻辑或者其他逻辑都是一段代码逻辑而已，没什么特别的。
讲回中断处理程序，既然他是内核中预先写好的一段处理逻辑，那就需要维护下元信息，就是这些处理逻辑放在内核的什么地方，这就是中断描述符表。中断描述符表是存储中断描述符的数组，中断向量就是数组的序号。该表在内核初始化的时候直接初始化赋值，表
的线性地址存放在 idtr 寄存器中。 每个中断描述符有 8 字节，其中中断门描述符 中比较重要的字段是段选择符、中断处理程序在段内的逻辑地址和 DPL(Descriptor privilege Level)。
* 段选择符：指明中断处理程序属于哪个段。因为都属于内核代码，所以都是 $Kernel_Code，放入 cs 寄存器中。
* 中断处理程序在段内的逻辑地址：之前说过 linux 不使用段的概念，所以段 base 都是 0，这个逻辑地址和线性地址值也就一样。因为中断只有中断向量传递给内核，所以具体要跳转的处理程序开头地址就是这个字段的值，放在 eip 中。
* DPL: 用于编程异常时检查权限。正常硬件中断检查的是 GDT 中段描述符的 DPL，不是这里的 DPL。

3. 跳转中断处理程序
简单描述中断是如何被处理的：
a: 硬件触发一个中断。
b: 在执行完一个指令之后，CPU 中硬件电路检查是否有中断或者异常的电信号。发现有，硬件电路读取引脚上传递过来的中断向量，查 IDT 中断向量表和 GDT 段描述符表。对比当前 cs 寄存器中的 CPU 特权 CPL 和段描述符中的代码特权级 DPL，允许在用户态
或者内核态时处理中断，但是不允许内核调用系统调用这种奇怪的场景。
c: 权限检查通过后，如果当前是用户态，需要先把 ss 和 esp 寄存器的值指向当前进程的内核栈，然后把旧的 ss、esp、cs 和 eip 这些寄存器的值压入内核栈中。注意，这里是 CPU 内部的硬件电路保存了部分的硬件上下文，后面内核还要保留部分硬件上下文才能
完整恢复执行流。
d: 将对应中断描述符中的段选择符装载到 cs 寄存器中，将中断描述符中的逻辑地址装载到 eip 寄存器中。从这里开始，CPU 开始执行内核中对应的中断处理代码了。

这里有个很核心的概念，就是内核栈。



### 异常

### 系统调用
在刚接触编程的时候，由于对系统设计不熟悉，总是好不清楚系统库和系统调用的关系。Linux 中的系统库常见的是 libc 和 libc++, 而系统调用则是 read 和 write 之类的函数。系统库是一系列函数的集合，有些函数内部调用了系统调用，有些
函数则只是操作系统封装的一些便捷操作，比如 math 函数集。



1. 库函数和系统调用的区别

2. 硬件上下文保存和恢复

## 硬件上下文存储和恢复


#总结