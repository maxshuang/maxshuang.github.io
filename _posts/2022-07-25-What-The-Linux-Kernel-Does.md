---
layout: post
title: (Script)What The Linux Kernel Does
subtitle: pic from 
author: maxshuang
categories: Linux-Kernel
banner:
  image:  
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 3.00em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
tags: Linux-Kernel 
---

最近团队在开发一个数据迁移的统一资源调度平台 Tiflow Engine，以便统一抽象 Data Platform 团队多个产品的资源调度能力和 Failover 能力。从 DP 
产品的功能上看，我们其实希望 Tiflow Engine 的最终形态是类似 Flink 这种流式计算框架，通过统一的流式算子抽象和 UDF 构建端到端的数据库同步流。
至于为什么不直接使用 Flink 而是重新造一个轮子，这里有技术栈的问题，也有已有业务的改造成本问题。我们希望通过制定 roadmap 逐步构建具备良好
流式抽象和 Cloud Native 特性的产品。这个 Blog 的目的不是讨论 Tiflow Engine，而是我在思考我们要做的最终东西的过程中想到的关于 Linux Kernel 的问题。

最开始我从 main 函数开始写代码的时候，觉得写的代码在逻辑上是一个很容易理解的事情。从 main 函数入口开始顺序执行，中间调用各种函数，直到退出 main 函数结束。我完成了我想要
做的事情，再复杂一点就是创建一些`并行`的线程，加上一些锁。然后这样写了两年代码之后，我发现了一些有点难以理解的事情，会有一个 C Runtime Lib
的东西和很多复杂的数据结构设计，比如 malloc 效率不高需要使用 tcmalloc 或者 jmalloc，深入里面看就是各种每线程变量 + 多级内存池。可以理解，但
不完全理解，我总觉得这些设计背后有些内容我没有 Get 到。

后来深入去找这些问题的答案的时候，我发现了原来这些问题的背后都是抽象和封装的问题。现代高级语言和操作系统提供了非常高级别的抽象和封装，以至
于我们使用 C/C++ 这类高级语言写逻辑时总认为我们处于一个纯粹简单的上下文环境中，我们的代码从头顺序得执行到结束。满足快速开发的需求，但是却容
易让人不理解这是个什么东西。从我们编写的高级语言到 CPU 真正执行的机器指令，中间隔了语言运行时、编译器、链接器、装载器、可执行文件格式、操作
系统进程管理、地址空间映射、运行队列、进程切换，才可能到我们编写的 main 函数执行。原来我们写的东西经过了这么长的链路才能被真正执行，那如果我要
优化我写的程序，我就有点崩溃了，如果我不能真正了解整个链路，我要怎么确保我的优化是合理且有效的。在这么多设计中，我如何知道我的设计在原理上
是更加好的，我做到了最好了吗？

说得有点远了，像链接装载器和可执行文件格式，背后更多的是关于格式的约定和模块的复用(链接器背后已经涉及到线性地址空间的文件映射了)，为了弄清楚
如何提供一个有效高级的资源管理抽象，这一系列博客值讨论关于 Linix Kernel 中的资源抽象。

写过高级语言的同学一开始除了接触语言提供的语法之外，另外一个重点理解的是进程关于堆和栈的概念，函数调用用栈，小空间用栈，大空间用堆。再深入问下
就是为什么要抽象出堆和栈的概念？堆和栈是什么？为什么同样都是拿到一个 4G 地址空间中的一个地址，会是不一样的呢？于是我们遇到了 Linux Kernel 关于
内存资源的抽象。另一方面，从我们写代码的角度看，代码被顺序不间断得执行，遇到阻塞的 I/O 时执行流会等待，然后恢复，多么符合线性思考习惯，一个好的
执行流抽象就应该要做到这种程度。但是再深入思考，`执行流会等待然后恢复`具体是什么意思呢? 具体底层实现是什么样子的? 于是我们遇到了 Linux Kernel
关于 CPU 资源的抽象。这里还是关于 IO 的抽象，以后我们再补充。

为了了解 Linux Kernel 关于 CPU 和内存资源的抽象，我阅读了《Understanding The Linux Kernel》这本书，内核中各种精巧的数据结构/高效率缓存涉及/寄存器
利用总是让我遇到写上一句`天才`的旁白。后来我问了自己，在一堆复杂设计的背后，内核真正做的是什么？如果让我来实现内核的话，我会实现成什么样子？这个
问题有点恐怖，我拿到的是什么？我拿到的是一个能被时钟信号驱动不断去取指令顺序执行的 CPU，和物理空间从 0 到 N 线性寻址的内存硬件。这就有点类似做算法
题，给你一段 0～N 的内存地址空间，请从头实现一个高级的内存分配器，要怎么设计数据结构？怎么存储内存分配器的元数据？怎么组织可用的内存空间？原来我
和内核面对的是同样简单设计的硬件结构，内核确已经在这样简单可理解的硬件上面，提供了 CPU 分时复用和线性地址空间这样超级高效的资源利用抽象和封装，
关键的关键还是写代码的人甚至在不知道这些抽象的情况下，都可以完成一些简单的工作。想到这里，Linux Kernel 关于资源利用的抽象真是令人佩服。
