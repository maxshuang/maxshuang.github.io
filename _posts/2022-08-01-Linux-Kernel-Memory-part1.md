---
layout: post
title: (script)Linux Kernel Memory(Part 1)
subtitle:
author: maxshuang
categories: Linux-Kernel
banner:
  image: /assets/images/post/linux-kernel-memory-part1/pexels-pixabay-52717.jpg
  opacity: 0.618
  background: "#000"
  height: "70vh"
  min_height: "38vh"
  heading_style: "font-size: 3.00em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
tags: Linux-Kernel Memory
---

从今天开始我们会将 Linux Kernel 内存管理相关的内容，因为这部分比较庞杂，有些设计上的考量没有完全搞清楚，所以会长期处于 script 状态。

如果你之前看过一些 Linux Kernel 内存管理和 Linux Kernel 源码，你会看到类似下面这种汇编指令片段：
```
movl $(__KERNEL_DS),%eax
movl %eax,%ds
movl %eax,%es
```
这里我们需要关注 ds 和 es, 他们是两个段寄存器。我们讲述内存管理是从段的概念开始的。接下来我们开始问比较核心的问题。

平时用的指针地址是什么？
对于某些人来说，这个问题问得有些奇怪，地址就是地址，是个大整数，为什么要问地址是什么这么无聊的问题。的确，如果你是使用 C/C++ 这种直接
操作指针管理内存的语言，使用 printf 打印出某个指针的地址，你会看到一个大整数，或者一个 0x 开头的 16 进制整数，在 32 bit 机器上这个
整数的范围是在 0 ～ 4G 之间。看起来问这个问题有些多余，不就是一个线性的地址，用整数表示，和数学上的表示一样。
如果再深入去看 Linux Kernel，你就会感觉到地址这个概念存在的违和感，地址空间的变更(比如进程切换时)总是伴随着对段寄存器的修改。

为什么 Linux Kernel 总要去变更段寄存器？
因为我们平时写代码时操作的地址在概念上并不是一个 0 ～ 4G 的线性地址，而是一个逻辑地址而已。什么叫逻辑地址？这个是 CPU 硬件寻址逻辑产生
的一个虚拟概念，表示的是在段内的偏移量，CPU 其实是按段寻址的。CPU 在执行机器指令的时候，会拿到一个逻辑地址，CPU 首先会读取 16 bit CodeSegment(CS)
或者 DataSegment(DS) 寄存器中的段选择符, 将高 13 bit 转成一个整数索引号，去全局描述符表中查询对应的段描述符。每个段描述符有 64 bit，
其中包括段相对于线性地址 0 的基址偏移，CPU 将这个基址偏移量加上逻辑地址表示的段内偏移量，就能得到线性地址，再通过某种方式将线性地址转成
物理地址，通过内存驱动访问具体物理地址的内存数据。这个流程概括起来就是：
CPU -> 段寄存器 -> 全局描述符 -> 段基址偏移 Base + 逻辑地址(段内偏移) -> 线性地址 -> 物理地址 -> 内存驱动 -> 内存数据

既然我们平时操作的地址是逻辑地址，为什么我们在使用上感觉地址更像是个线性地址？比如我将一个文件映射到进程内存空间时，如果是个新段，则打印
地址时偏移量应该从 0 开始才对，但是实际上还是一个很大的数字。
因为 Linux Kernel 在实现上没有使用 Base 的能力，所有段的段描述符的 Base 字段都设置成 0，所以逻辑地址其实和线性地址相等了。

解释完逻辑地址这个概念之后，我们就知道内核代码中关于操作段寄存器的意义了，比如在做系统调用时，需要做用户态到内核态的切换。我们在说用户态
到内核态切换这个对 linux 工程师比较普通的表述时，其实它隐藏的流程还是很多的，后面我们将 CPU 的资源管理时再详细说明。这里我们只要了解切换
到内核态时，有对应的指令将内核代码段 `__KERNEL_CS` 和内核数据段 `__KERNEL_DS` 的段描述符装载到 cs 和 ds 寄存器中，以便读取对应段的特权级
等信息。

因为逻辑地址和线性地址的值一样，所以后面我们直接用线性地址去描述用户使用的地址。

说到这里，我们只说了逻辑地址和线性地址的区别。但线性地址又是什么？虽然在表现形式上是个整数区间内的连续数字，但是它要表达什么意义？为什么它
和我们常说的物理地址在形式上那么相似。
线性地址是进程地址空间抽象得到的一个概念，为了隐藏内核底层是如何管理物理内存的，内核给用户提供了一个有限的地址空间的概念。比如在 32 bit 机器
下进程可以访问 0 ～4G 的空间，这种抽象非常精彩，进程仿佛在独占物理内存，用户能使用线性的内存地址，非常符合线性的思考习惯。
在这层进程内存空间的抽象下面，CPU 总是需要获取到具体某个物理内存地址的数据，加载到寄存器中进行操作，这里就是 Linux Kernel 的分页管理。

分页管理
如何高效得利用内存资源一直是内核关注的问题，比如物理内存大小是256M，当只有一个进程时，是不是直接将 256M 的空间 1:1 直接映射到 4G 线性空间的
低地址？或者我们有 10 个进程，每个进程有 4G 的线性空间，那要如何映射256M 的物理内存才能满足用户需求？
我们知道，即使是一个进程，用户指令在运行时也不可能在短时间内访问大范围的内存空间，这个就是 locality 原理，所以就会有热内存区间和冷内存区间，
比如 4G 中，只有 100M 是热内存区间，其他的都是冷内存区间，甚至可能大部分进程只会访问总量是 200M 的地址区间(可能是离散的)。
在这种情况下，将物理内存区间固定得映射到线性地址空间中，就会有很大的资源浪费。怎么解决这个问题？内存复用。

内存复用的意思是说，我希望同一块物理内存，当进程A 主动释放或者长时间不使用这块物理内存时，就将这块内存给进程B 使用，为了隐藏底层的内存复用，
我在线性地址和物理地址之间搞个表维护这种映射关系，以便可以查找，比如线性地址 [0, 10) => 物理地址 [1000, 1010)。 


















